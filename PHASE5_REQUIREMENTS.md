# Phase 5 功能需求文档

> **项目**: T66Y 论坛归档系统
> **阶段**: Phase 5 - 定时任务与 MQTT 通知系统
> **版本**: v2.0 (MQTT 方案)
> **创建日期**: 2026-02-15
> **更新日期**: 2026-02-15
> **状态**: 需求确认 ✅

---

## 📋 目录

1. [项目背景](#1-项目背景)
2. [功能目标](#2-功能目标)
3. [功能需求](#3-功能需求)
4. [用户故事](#4-用户故事)
5. [非功能需求](#5-非功能需求)
6. [验收标准](#6-验收标准)
7. [优先级划分](#7-优先级划分)
8. [依赖与约束](#8-依赖与约束)

---

## 1. 项目背景

### 1.1 当前状态（Phase 4 完成）

**已实现功能**：
- ✅ 作者关注与管理
- ✅ 手动归档下载
- ✅ 增量检测新帖（手动触发）
- ✅ 数据库统计与分析
- ✅ EXIF 提取与可视化
- ✅ 分析报告生成

**现有痛点**：
- ❌ 需要手动执行更新操作
- ❌ 无法得知任务完成状态（除非盯着屏幕）
- ❌ 错过新帖发布时机（依赖手动检查）
- ❌ 无法无人值守运行
- ❌ 多个自动化项目需要管理多个通知渠道

### 1.2 Phase 5 目标

**核心诉求**：
1. **自动化运行**：系统按计划自动检查和下载新帖
2. **解耦通知**：使用 MQTT 消息总线，与通知渠道解耦
3. **统一架构**：多个自动化项目共享同一套通知基础设施
4. **灵活配置**：用户可自定义定时规则和消息格式
5. **增量下载**：只下载上次以后的新帖，节省时间和带宽

**价值**：
- 解放用户时间（无需手动操作）
- 降低遗漏风险（自动检测新帖）
- 架构优雅（消息生产者和消费者分离）
- 易于扩展（一个 MQTT Broker 服务多个项目）
- 提高系统可用性（24/7 无人值守）

---

## 2. 功能目标

### 2.1 核心功能（必须实现）

| ID | 功能名称 | 描述 | 优先级 |
|----|----------|------|--------|
| **F-01** | 定时任务管理 | 添加/编辑/删除/查看定时任务 | P0 |
| **F-02** | 增量归档 | 只下载上次归档后的新帖子 | P0 |
| **F-03** | 任务调度执行 | 按 Cron 表达式自动执行任务 | P0 |
| **F-04** | MQTT 消息发布 | 任务完成/失败时发布结构化消息到 MQTT | P0 |
| **F-05** | MQTT 配置 | 配置 MQTT Broker 连接信息 | P0 |
| **F-06** | 任务执行日志 | 记录每次任务的执行结果 | P0 |

### 2.2 扩展功能（可选实现）

| ID | 功能名称 | 描述 | 优先级 |
|----|----------|------|--------|
| **F-07** | 手动触发任务 | 不等定时，立即执行某个任务 | P1 |
| **F-08** | 任务执行历史 | 查看历史执行记录和统计 | P1 |
| **F-09** | 多通知渠道 | 支持终端、日志文件、MQTT | P1 |
| **F-10** | 任务失败重试 | 失败后自动重试 N 次 | P2 |
| **F-11** | 消息过滤规则 | 根据消息级别过滤发布 | P2 |
| **F-12** | 消息处理器示例 | 提供 MQTT → Telegram 参考实现 | P2 |

---

## 3. 功能需求

### 3.1 定时任务管理（F-01）

#### 需求描述
用户可以通过 UI 界面管理定时任务，包括创建、编辑、删除、启用/禁用任务。

#### 功能细节

**3.1.1 添加任务**
- 输入项：
  - 任务名称（必填，字符串，最多50字符）
  - 选择作者（必填，从关注列表选择）
  - 定时规则（必填）：
    - 预设模板：每天、每周、每6小时、每小时
    - 自定义 Cron 表达式
  - 执行时间（如果选择"每天"，需要指定小时:分钟）
  - 扫描页数（可选，默认3，范围1-10）
- 验证规则：
  - 任务名称不能与现有任务重复
  - Cron 表达式必须合法
  - 作者必须在关注列表中
- 输出：
  - 成功：显示任务详情，分配唯一 task_id
  - 失败：显示错误提示

**3.1.2 查看任务列表**
- 显示内容：
  - 任务 ID
  - 任务名称
  - 作者名称
  - 定时规则（可读格式："每天 03:00"）
  - 状态（已启用/已禁用）
  - 上次执行时间
  - 上次执行结果（成功/失败，新增帖子数）
  - 下次执行时间
- 排序：按下次执行时间升序
- 交互：选择任务后可编辑/删除/手动执行

**3.1.3 编辑任务**
- 可修改项：
  - 任务名称
  - 定时规则
  - 执行时间
  - 扫描页数
  - 启用/禁用状态
- 不可修改项：
  - 任务 ID
  - 作者（需要删除后重新创建）
- 修改后：
  - 立即生效（重新计算下次执行时间）
  - 记录修改日志

**3.1.4 删除任务**
- 确认提示："确定删除任务 [任务名称] 吗？"
- 删除后：
  - 从调度器移除
  - 从配置文件删除
  - 保留历史执行记录（可选）

**3.1.5 启用/禁用任务**
- 禁用任务：
  - 从调度器移除，但保留配置
  - 状态显示为"已禁用"
- 启用任务：
  - 重新添加到调度器
  - 重新计算下次执行时间

#### 数据存储
- 配置文件：`config.yaml` 的 `scheduler_tasks` 数组
- 调度器状态：`python/data/scheduler_jobs.db`（APScheduler 自动管理）

#### UI 交互
```
主菜单 → "⏰ 定时任务管理"
  ├─ "📋 查看所有任务"
  ├─ "➕ 添加定时任务"
  ├─ "✏️ 编辑任务"
  ├─ "🗑️ 删除任务"
  ├─ "▶️ 手动执行任务"
  ├─ "📊 查看执行历史"
  └─ "🔙 返回主菜单"
```

---

### 3.2 增量归档（F-02）

#### 需求描述
定时任务执行时，只下载该作者自上次归档后发布的新帖子，跳过已归档的帖子。

#### 功能细节

**3.2.1 增量检测**
- 调用现有的 `PostChecker.check_new_posts(author_name, author_url, max_pages)`
- 返回结果：
  ```python
  {
      'has_new': True,
      'new_count': 5,
      'new_urls': ['url1', 'url2', ...],
      'total_forum': 65,
      'total_archived': 60
  }
  ```

**3.2.2 增量下载**
- 如果 `has_new == False`：
  - 跳过下载，记录日志："未发现新帖"
  - 发送通知（可选）
  - 任务标记为"成功"
- 如果 `has_new == True`：
  - 调用 `ForumArchiver.archive_author(target_urls=new_urls)`
  - 只归档 `new_urls` 列表中的帖子
  - 跳过 Phase 1（收集URL），直接进入 Phase 2（逐个归档）

**3.2.3 进度跟踪**
- 实时显示：
  - "正在归档第 2/5 篇帖子..."
  - "下载图片 10/15 张..."
- 日志记录：
  - 每篇帖子的归档结果
  - 失败的帖子和错误原因

**3.2.4 数据同步**
- 归档完成后：
  - 更新 `PostTracker`（记录已归档 URL hash）
  - 更新数据库（`authors.last_update`）
  - 更新配置文件（`author.last_update`）

#### 技术要求
- 修改 `ForumArchiver.archive_author()` 方法，增加 `target_urls` 参数
- 参数为 `None` 时：正常流程（收集+归档）
- 参数为 `List[str]` 时：增量流程（直接归档）

#### 性能指标
- 增量检测时间：< 30秒（扫描3页）
- 单帖归档时间：< 60秒（包含图片下载）
- 总任务时间：< 10分钟（5篇新帖）

---

### 3.3 任务调度执行（F-03）

#### 需求描述
系统使用 APScheduler 作为调度引擎，按用户配置的 Cron 表达式自动触发任务。

#### 功能细节

**3.3.1 调度器生命周期**
- 启动：
  - 主菜单进入"定时任务管理"时自动启动调度器
  - 或用户手动点击"▶️ 启动调度器"
  - 加载所有已启用的任务
  - 后台运行，不阻塞 UI
- 停止：
  - 用户点击"⏸️ 停止调度器"
  - 或退出主菜单时自动停止
  - 等待正在执行的任务完成后再停止

**3.3.2 任务触发**
- 触发时机：
  - 当前时间匹配 Cron 表达式时
  - 用户手动点击"▶️ 手动执行"时
- 触发流程：
  ```
  1. 检查是否有其他任务正在执行（互斥锁）
  2. 如果有，加入队列等待
  3. 如果没有，立即执行
  4. 执行完成后，释放锁，处理队列
  ```

**3.3.3 并发控制**
- 同一时间只允许 1 个归档任务运行（防止资源冲突）
- 使用 `asyncio.Lock()` 实现互斥
- 如果任务在执行时触发了下一次定时，下一次任务加入队列等待

**3.3.4 任务执行流程**
```python
async def execute_task(task_config):
    start_time = now()

    try:
        # 1. 增量检测
        result = await IncrementalArchiver.archive_author_incremental(
            author_name=task_config['author_name'],
            author_url=task_config['author_url'],
            max_pages=task_config['max_pages']
        )

        # 2. 记录日志
        save_execution_history(task_id, result, status='success')

        # 3. 发送通知
        NotificationManager.send_task_completion(result)

    except Exception as e:
        # 错误处理
        save_execution_history(task_id, error=str(e), status='failed')
        NotificationManager.send_task_error(task_name, str(e))
```

**3.3.5 下次执行时间计算**
- 任务执行完成后，APScheduler 自动计算下次执行时间
- UI 实时显示"下次执行：2026-02-16 03:00"

#### 技术规格
- 调度器：`APScheduler.BackgroundScheduler`
- 存储后端：`SQLAlchemyJobStore`（SQLite）
- 触发器：
  - `CronTrigger`（Cron 表达式）
  - `IntervalTrigger`（固定间隔，可选）

#### Cron 表达式支持
```
格式：分 时 日 月 周
示例：
  0 3 * * *     # 每天凌晨3点
  0 */6 * * *   # 每6小时
  0 2 * * 0     # 每周日凌晨2点
  30 14 * * 1-5 # 工作日下午2:30
```

---

### 3.4 MQTT 消息发布（F-04）

#### 需求描述
任务执行完成、失败或发现新帖时，发布结构化的 JSON 消息到 MQTT Broker，由消息处理器（用户自行实现）决定如何通知。

#### 功能细节

**3.4.1 消息发布时机**
| 事件 | 触发条件 | 消息类型 | 可配置 |
|------|----------|----------|--------|
| 任务完成 | 归档成功结束 | `task_completed` | ✅ |
| 任务失败 | 发生异常 | `task_failed` | ✅ |
| 发现新帖 | 检测到新帖（未下载前） | `new_posts_found` | ✅ |
| 任务开始 | 任务开始执行 | `task_started` | ✅（默认关闭）|

**3.4.2 消息格式（JSON）**

**消息 1：任务完成（task_completed）**
```json
{
  "source": "t66y-archiver",
  "timestamp": "2026-02-15 03:00:15",
  "event_type": "task_completed",
  "level": "INFO",
  "data": {
    "task_id": "task_1",
    "task_name": "每日更新-同花顺心",
    "author_name": "同花顺心",
    "start_time": "2026-02-15 03:00:00",
    "end_time": "2026-02-15 03:02:35",
    "duration": "2分35秒",
    "status": "success",
    "new_posts": 5,
    "skipped_posts": 55,
    "failed_posts": 0,
    "total_archived": 60,
    "total_forum": 65,
    "completion_rate": 92.3
  }
}
```

**消息 2：任务失败（task_failed）**
```json
{
  "source": "t66y-archiver",
  "timestamp": "2026-02-15 03:00:15",
  "event_type": "task_failed",
  "level": "ERROR",
  "data": {
    "task_id": "task_1",
    "task_name": "每日更新-同花顺心",
    "author_name": "同花顺心",
    "error": "net::ERR_ABORTED",
    "error_detail": "可能触发反爬虫机制"
  }
}
```

**消息 3：发现新帖（new_posts_found）**
```json
{
  "source": "t66y-archiver",
  "timestamp": "2026-02-15 03:00:15",
  "event_type": "new_posts_found",
  "level": "INFO",
  "data": {
    "author_name": "同花顺心",
    "new_count": 5,
    "next_run_time": "2026-02-16 03:00:00"
  }
}
```

**3.4.3 消息发布规则**
- 发布方式：`client.publish(topic, payload, qos=1)`
- QoS（消息质量）：
  - QoS 0：最多一次（可能丢失）
  - QoS 1：至少一次（默认，推荐）✅
  - QoS 2：恰好一次（最可靠，但较慢）
- 重试机制：
  - 发布失败时重试 3 次
  - 每次间隔 2 秒
  - 3 次均失败后记录到日志，不再重试
- 降级策略：
  - MQTT 不可用时，消息写入日志文件
  - 不影响任务执行流程

**3.4.4 消息级别控制**
- 用户可配置最低发布级别：
  - `DEBUG`：所有消息（包括调试信息）
  - `INFO`：常规消息（任务完成、发现新帖）✅ 默认
  - `WARNING`：警告消息
  - `ERROR`：仅错误（任务失败）

**3.4.5 Topic 规范**
- 主 Topic：`t66y/scheduler/events`
- 子 Topic（可选）：
  - `t66y/scheduler/events/completed` - 任务完成
  - `t66y/scheduler/events/failed` - 任务失败
  - `t66y/scheduler/events/new_posts` - 发现新帖
- 订阅方式：
  - `t66y/scheduler/events` - 订阅所有事件
  - `t66y/scheduler/events/+` - 订阅所有子 Topic
  - `t66y/#` - 订阅所有 t66y 消息

#### 技术规格
- 库：`paho-mqtt==1.6.1`
- 协议版本：MQTT v3.1.1
- 连接方式：持久连接（keep-alive=60秒）
- 超时时间：5秒
- 消息保留：默认不保留（retain=false）

---

### 3.5 MQTT 配置（F-05）

#### 需求描述
用户可以配置 MQTT Broker 的连接信息，包括地址、端口、认证等。

#### 功能细节

**3.5.1 配置入口**
```
主菜单 → "⏰ 定时任务管理" → "⚙️ 通知配置"
```

**3.5.2 配置流程**
```
步骤 1：提示信息
"请确保已安装并启动 MQTT Broker（如 Mosquitto）。
本地测试可使用 localhost:1883，无需认证。"

步骤 2：输入 Broker 地址
提示："MQTT Broker 地址（如 localhost 或 192.168.1.100）"
输入：[文本框]
默认值：localhost

步骤 3：输入端口
提示："MQTT Broker 端口"
输入：[数字框]
默认值：1883
验证：范围 1-65535

步骤 4：输入认证信息（可选）
提示："用户名（可选，无认证请留空）"
输入：[文本框]
提示："密码（可选）"
输入：[密码框]

步骤 5：输入 Topic
提示："消息主题（Topic）"
输入：[文本框]
默认值：t66y/scheduler/events

步骤 6：测试连接
- 发布测试消息到 Broker
- 成功：显示"✅ 配置已保存，MQTT 通知已启用"
- 失败：显示"❌ 连接失败，请检查 Broker 地址和端口"

步骤 7：保存配置
- 写入 `config.yaml`：
  ```yaml
  notification:
    mqtt:
      enabled: true
      broker: "localhost"
      port: 1883
      username: ""
      password: ""
      topic: "t66y/scheduler/events"
      qos: 1
  ```
```

**3.5.3 配置管理**
- 查看配置：
  - 显示 Broker 地址和端口
  - 显示 Topic
  - 显示密码（脱敏，显示为 ****）
  - 显示状态：已连接/未连接
- 编辑配置：
  - 重新输入配置项
  - 重新测试连接
- 禁用通知：
  - 设置 `enabled: false`
  - 保留配置（下次启用时无需重新输入）

**3.5.4 安全性**
- 敏感信息存储：
  - 方案 A：直接写入 `config.yaml`（默认）
  - 方案 B：使用环境变量（高级用户）
- 本地部署优势：
  - Broker 运行在本地，无需担心数据泄露
  - 可选 TLS 加密（生产环境）

#### 数据结构
```yaml
notification:
  enabled: true

  console:
    enabled: true
    min_level: INFO

  file:
    enabled: true
    log_path: ./logs/notifications.log
    min_level: INFO

  mqtt:
    enabled: false              # 默认关闭，用户配置后启用
    broker: "localhost"         # MQTT Broker 地址
    port: 1883                  # MQTT Broker 端口
    username: ""                # 可选认证
    password: ""
    topic: "t66y/scheduler/events"  # 消息主题
    qos: 1                      # 消息质量（0/1/2）
    retain: false               # 是否保留消息
    client_id: "t66y-archiver"  # 客户端 ID

    # 消息发布配置
    publish_on:
      task_start: false         # 任务开始时发布
      task_complete: true       # 任务完成时发布
      task_error: true          # 任务失败时发布
      new_posts_found: true     # 发现新帖时发布

    # 消息格式配置
    format:
      include_timestamp: true   # 包含时间戳
      include_source: true      # 包含来源标识
```

---

### 3.6 任务执行日志（F-06）

#### 需求描述
系统记录每次定时任务的执行结果，用于审计和故障排查。

#### 功能细节

**3.6.1 日志内容**
每次任务执行记录以下信息：
- 任务 ID
- 任务名称
- 作者名称
- 开始时间（精确到秒）
- 结束时间
- 耗时（秒）
- 执行状态：`success` | `failed` | `partial`
- 新增帖子数
- 跳过帖子数
- 失败帖子数
- 错误信息（如果失败）

**3.6.2 存储方式**

**方案 A：数据库（推荐）**
```sql
CREATE TABLE scheduler_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    task_id TEXT NOT NULL,
    task_name TEXT NOT NULL,
    author_name TEXT NOT NULL,
    start_time TEXT NOT NULL,
    end_time TEXT,
    duration_seconds REAL,
    status TEXT NOT NULL,  -- success | failed | partial
    new_posts INTEGER DEFAULT 0,
    skipped_posts INTEGER DEFAULT 0,
    failed_posts INTEGER DEFAULT 0,
    error_message TEXT,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_scheduler_history_task ON scheduler_history(task_id);
CREATE INDEX idx_scheduler_history_time ON scheduler_history(start_time);
```

**方案 B：日志文件（备选）**
- 文件：`logs/scheduler_history.log`
- 格式：JSON Lines（每行一条 JSON）
```json
{"task_id":"task_1","start_time":"2026-02-15 03:00:00","status":"success","new_posts":5}
```

**3.6.3 日志查询**
- 按任务 ID 查询：查看某个任务的所有执行记录
- 按时间范围查询：查看最近 N 天的记录
- 按状态查询：只看失败的记录
- 统计分析：
  - 任务成功率
  - 平均耗时
  - 平均新增帖子数

**3.6.4 日志清理**
- 保留策略：
  - 最近 30 天：全部保留
  - 30-90 天：每天保留 1 条（最新的）
  - 90 天以上：删除
- 清理时机：每周日凌晨 4 点自动清理

#### UI 展示
```
主菜单 → "⏰ 定时任务管理" → "📊 查看执行历史"

筛选：
  任务：[所有任务 ▼]
  状态：[全部 ▼]
  时间：[最近7天 ▼]

结果列表：
┌─────────────────────────────────────┐
│ 2026-02-15 03:00:15                 │
│ ✅ 每日更新-同花顺心                 │
│ 耗时：2分35秒 | 新增：5篇           │
├─────────────────────────────────────┤
│ 2026-02-14 03:00:10                 │
│ ✅ 每日更新-同花顺心                 │
│ 耗时：1分20秒 | 新增：2篇           │
├─────────────────────────────────────┤
│ 2026-02-13 03:00:05                 │
│ ❌ 每日更新-同花顺心                 │
│ 错误：net::ERR_ABORTED              │
└─────────────────────────────────────┘

[查看详情] [导出 CSV]
```

---

## 4. 用户故事

### 4.1 核心场景

**用户故事 1：设置定时任务**
```
作为 用户
我想要 设置每天凌晨 3 点自动下载某作者的新帖
以便 不需要手动操作，系统自动运行

验收标准：
- ✅ 可以选择作者
- ✅ 可以设置"每天"+ 具体时间
- ✅ 保存后自动计算下次执行时间
- ✅ 下次执行时间正确显示
```

**用户故事 2：发布消息到 MQTT**
```
作为 用户
我想要 在任务完成后发布消息到 MQTT
以便 我的消息处理器可以接收并决定如何通知我

验收标准：
- ✅ 任务完成后 5 秒内发布消息到 MQTT
- ✅ 消息格式为 JSON，包含完整统计信息
- ✅ 消息可被其他系统订阅和消费
- ✅ 消息发布失败不影响任务执行
```

**用户故事 3：增量下载**
```
作为 用户
我想要 系统只下载新帖，跳过已归档的
以便 节省时间和带宽

验收标准：
- ✅ 系统自动检测新帖
- ✅ 只下载新帖，不重复下载
- ✅ 如果没有新帖，跳过归档
- ✅ 通知中显示"新增：0 篇"
```

**用户故事 4：查看任务状态**
```
作为 用户
我想要 随时查看定时任务的状态和历史
以便 了解系统运行情况

验收标准：
- ✅ 显示所有任务列表
- ✅ 显示下次执行时间
- ✅ 显示上次执行结果
- ✅ 可以查看详细历史记录
```

**用户故事 5：配置 MQTT**
```
作为 用户
我想要 快速配置 MQTT 连接
以便 启用消息发布功能

验收标准：
- ✅ 配置流程简单（3分钟内完成）
- ✅ 提供清晰的配置指引
- ✅ 自动测试连接
- ✅ 保存后立即生效
- ✅ 支持本地 Broker（无需外网）
```

### 4.2 异常场景

**用户故事 6：处理任务失败**
```
作为 用户
我想要 在任务失败时发布错误消息
以便 我的消息处理器可以通知我并记录日志

验收标准：
- ✅ 失败时立即发布错误消息到 MQTT
- ✅ 消息包含完整的错误信息
- ✅ 消息级别为 ERROR（便于过滤）
- ✅ 可以手动重试失败的任务
```

**用户故事 7：避免任务冲突**
```
作为 用户
我想要 系统自动避免多个任务同时运行
以便 防止资源冲突和重复下载

验收标准：
- ✅ 同时只能有 1 个任务执行
- ✅ 后续任务自动排队等待
- ✅ 等待中的任务显示"排队中"状态
- ✅ 等待超过 1 小时自动取消
```

---

## 5. 非功能需求

### 5.1 性能需求

| 指标 | 目标值 | 测量方法 |
|------|--------|----------|
| 任务执行时间 | < 10 分钟（5篇新帖） | 记录开始和结束时间 |
| 增量检测时间 | < 30 秒（扫描3页） | 独立计时 |
| 通知发送延迟 | < 5 秒 | 记录发送时间差 |
| 系统内存占用 | < 500 MB | `psutil` 监控 |
| CPU 占用率 | < 30%（执行时） | `psutil` 监控 |

### 5.2 可靠性需求

| 需求 | 描述 | 实现方式 |
|------|------|----------|
| 任务不丢失 | 系统重启后任务自动恢复 | APScheduler 持久化 |
| 错误恢复 | 单个任务失败不影响其他任务 | 异常捕获和隔离 |
| 日志完整 | 所有执行记录可追溯 | 数据库或日志文件 |
| 通知可靠 | 发送失败后重试 3 次 | 重试机制 |

### 5.3 可用性需求

| 需求 | 描述 | 验收标准 |
|------|------|----------|
| 易于配置 | 5分钟内完成首次配置 | 用户测试 |
| 界面友好 | 操作流程清晰，无需文档 | 用户测试 |
| 错误提示 | 错误信息易于理解 | 用户测试 |
| 文档完整 | 提供配置指南和故障排查 | 文档审查 |

### 5.4 安全性需求

| 需求 | 描述 | 实现方式 |
|------|------|----------|
| 敏感信息保护 | Bot Token 不明文显示 | 脱敏显示 |
| 配置文件安全 | 不提交敏感信息到 Git | .gitignore |
| 权限控制 | 配置文件只有用户可读 | 文件权限 644 |

### 5.5 兼容性需求

| 需求 | 描述 | 验证方法 |
|------|------|----------|
| Python 版本 | Python 3.10+ | 测试环境 |
| 操作系统 | Linux, macOS, Windows | 多平台测试 |
| 现有功能兼容 | 不影响 Phase 1-4 功能 | 回归测试 |

---

## 6. 验收标准

### 6.1 功能验收

#### 定时任务管理
- [ ] 可以添加任务（所有字段正确保存）
- [ ] 可以编辑任务（修改立即生效）
- [ ] 可以删除任务（从调度器和配置移除）
- [ ] 可以启用/禁用任务
- [ ] 任务列表正确显示所有信息
- [ ] 下次执行时间计算正确

#### 增量归档
- [ ] 只下载新帖（已归档的跳过）
- [ ] 无新帖时跳过归档
- [ ] 新帖检测准确（无遗漏，无误报）
- [ ] PostTracker 正确更新
- [ ] 数据库同步正确

#### 任务调度
- [ ] 任务按时自动执行
- [ ] 调度器可启动和停止
- [ ] 同时只有 1 个任务运行
- [ ] 任务冲突时正确排队
- [ ] 手动执行立即触发

#### MQTT 消息发布
- [ ] 任务完成后发布消息（5秒内）
- [ ] 任务失败后发布错误消息
- [ ] 消息格式为 JSON（结构正确）
- [ ] 消息内容完整（包含所有统计信息）
- [ ] 发布失败时正确降级到日志

#### MQTT 配置
- [ ] 可以输入 Broker 地址、端口、Topic
- [ ] 输入验证正确
- [ ] 测试连接功能正常
- [ ] 配置保存到文件
- [ ] 配置加载正确
- [ ] 支持可选认证（用户名/密码）

#### 执行日志
- [ ] 每次执行都有记录
- [ ] 记录内容完整（所有字段）
- [ ] 可以按条件查询
- [ ] 可以导出 CSV
- [ ] 日志自动清理

### 6.2 性能验收

- [ ] 单任务执行时间 < 10 分钟（5篇新帖）
- [ ] 增量检测时间 < 30 秒（3页）
- [ ] 通知发送延迟 < 5 秒
- [ ] 内存占用 < 500 MB
- [ ] CPU 占用 < 30%

### 6.3 可靠性验收

- [ ] 系统重启后任务自动恢复
- [ ] 单个任务失败不影响其他任务
- [ ] 所有错误都有日志
- [ ] 通知发送失败后重试 3 次
- [ ] 连续运行 7 天无崩溃

### 6.4 用户体验验收

- [ ] 首次配置时间 < 5 分钟
- [ ] 操作流程直观（无需查看文档）
- [ ] 错误提示清晰易懂
- [ ] Telegram 消息格式友好
- [ ] 任务状态实时更新

---

## 7. 优先级划分

### P0（必须实现，1 周）
- F-01: 定时任务管理（CRUD）
- F-02: 增量归档
- F-03: 任务调度执行
- F-04: Telegram 通知（任务完成/失败）
- F-05: 通知配置
- F-06: 任务执行日志（数据库）

### P1（重要，3 天）
- F-07: 手动触发任务
- F-08: 任务执行历史查询
- F-09: 多通知渠道（Console + File + Telegram）

### P2（可选，未来迭代）
- F-10: 任务失败重试
- F-11: 静音时段

### P3（扩展，Phase 6）
- F-12: Telegram 交互命令

---

## 8. 依赖与约束

### 8.1 技术依赖

| 依赖项 | 版本 | 用途 | 必须 |
|--------|------|------|------|
| APScheduler | 3.10.4 | 任务调度 | ✅ |
| paho-mqtt | 1.6.1 | MQTT 客户端 | ✅ |
| Mosquitto | 2.x | MQTT Broker（用户自行安装）| ✅ |
| SQLite | 3.x | 数据存储 | ✅ |
| Python | 3.10+ | 运行环境 | ✅ |

### 8.2 功能依赖

| 依赖功能 | 所属阶段 | 状态 | 说明 |
|----------|----------|------|------|
| PostTracker | Phase 2 | ✅ 已完成 | 新帖检测 |
| PostChecker | Phase 2 | ✅ 已完成 | URL 对比 |
| ForumArchiver | Phase 2 | ✅ 已完成 | 归档下载 |
| 数据库 | Phase 3 | ✅ 已完成 | 数据存储 |

### 8.3 约束条件

#### 技术约束
- 必须使用 APScheduler（不使用 Celery）
- 必须使用 SQLite（不使用 PostgreSQL/MySQL）
- 必须使用 python-telegram-bot（不使用 aiogram）
- 必须复用现有的 PostChecker 和 ForumArchiver

#### 业务约束
- 同时只能运行 1 个归档任务
- 扫描页数限制 1-10 页
- Telegram 消息长度 < 4096 字符
- 任务名称长度 < 50 字符

#### 时间约束
- Phase 5 总工期：2 周
- P0 功能：1 周
- P1 功能：3 天
- 测试优化：2 天

---

## 9. 消息处理器（用户侧）

### 9.1 架构说明

本项目负责发布消息到 MQTT Broker，但**不负责**消息的最终处理（如发送 Telegram、邮件等）。

用户需要自行实现**消息处理器**（独立程序），订阅 MQTT 消息并决定如何处理。

**优势**：
- ✅ 解耦：项目与通知渠道完全分离
- ✅ 灵活：可以随时更换通知方式，无需修改项目代码
- ✅ 统一：一个消息处理器可以服务多个自动化项目
- ✅ 可扩展：支持多种通知渠道（Telegram、邮件、Web、钉钉等）

### 9.2 消息处理器示例（参考实现）

项目将提供一个**参考实现**（`python/tools/mqtt_to_telegram.py`），用户可以直接使用或修改。

**功能**：
- 订阅 MQTT 消息
- 将消息格式化为 Markdown
- 发送到 Telegram

**使用方式**：
```bash
# 安装依赖
pip install paho-mqtt python-telegram-bot

# 配置环境变量（或直接修改脚本）
export MQTT_BROKER="localhost"
export MQTT_TOPIC="t66y/#"
export TELEGRAM_BOT_TOKEN="你的Bot Token"
export TELEGRAM_CHAT_ID="你的Chat ID"

# 运行
python python/tools/mqtt_to_telegram.py

# 后台运行（推荐）
nohup python python/tools/mqtt_to_telegram.py > /dev/null 2>&1 &

# 或使用 systemd 服务（Linux）
sudo systemctl enable mqtt-to-telegram.service
sudo systemctl start mqtt-to-telegram.service
```

### 9.3 消息处理器部署建议

**方案 A：独立 Python 脚本（推荐）**
- 简单：一个 Python 文件
- 灵活：可随时修改逻辑
- 适合：个人用户

**方案 B：Node-RED（可视化）**
- 无需编程：图形化配置
- 强大：支持多种集成
- 适合：非技术用户

**方案 C：Home Assistant（智能家居）**
- 集成：与智能家居系统集成
- 丰富：支持多种通知方式
- 适合：已有 Home Assistant 用户

### 9.4 多项目共享

如果你有多个自动化项目（如本项目、照片整理、数据备份等），可以让它们都发消息到同一个 MQTT Broker，然后用**一个消息处理器**统一处理：

```
项目A (t66y-archiver)    ─┐
项目B (photo-organizer)  ─┼─> MQTT Broker ─> 统一消息处理器 ─> Telegram
项目C (backup-tool)      ─┘                                  ├─> 邮件
                                                              └─> Web Dashboard
```

**Topic 规划建议**：
- `t66y/scheduler/events` - T66Y 归档系统
- `photos/events` - 照片整理工具
- `backup/events` - 备份工具

消息处理器订阅 `#`（所有消息）或特定项目的 Topic。

---

## 10. 附录

### 10.1 术语表

| 术语 | 定义 |
|------|------|
| 定时任务 | 按计划自动执行的归档任务 |
| 增量归档 | 只下载新帖，跳过已归档的帖子 |
| Cron 表达式 | 时间计划表达式，如 `0 3 * * *` |
| MQTT | Message Queuing Telemetry Transport，轻量级消息协议 |
| MQTT Broker | MQTT 消息代理服务器（如 Mosquitto） |
| Topic | MQTT 消息主题，用于消息路由 |
| QoS | Quality of Service，消息质量等级（0/1/2） |
| Publisher | 消息发布者（本项目） |
| Subscriber | 消息订阅者（消息处理器） |
| 任务调度器 | 管理和执行定时任务的系统组件 |
| 通知管理器 | 统一的消息发布接口 |

### 10.2 参考文档

- APScheduler 官方文档：https://apscheduler.readthedocs.io/
- paho-mqtt 文档：https://pypi.org/project/paho-mqtt/
- MQTT 协议规范：https://mqtt.org/
- Mosquitto 官方网站：https://mosquitto.org/
- Cron 表达式：https://crontab.guru/

---

**文档结束**

> **审批**：
> - 产品负责人：_______ 日期：_______
> - 技术负责人：_______ 日期：_______
> - 用户代表：_______ 日期：_______
